package darkoverload.itzip.feature.resume.mock;

import darkoverload.itzip.feature.resume.domain.career.Career;
import darkoverload.itzip.feature.resume.domain.resume.Resume;
import darkoverload.itzip.feature.resume.service.resume.port.career.CareerReadRepository;
import darkoverload.itzip.feature.resume.service.resume.port.career.CareerRepository;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;

public class FakeCareerRepository implements CareerRepository, CareerReadRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<Career> data = Collections.synchronizedList(new ArrayList<>());

    @Override
    public List<Career> findAllByResumeId(Long resumeId) {
        return data.stream()
                .filter(career -> Objects.equals(career.getResume().getResumeId(), resumeId))
                .toList();
    }

    @Override
    public Career save(Career career) {
        if (career.getCareerId() == null || career.getCareerId() == 0) {
            Career newCareer = Career.builder()
                    .careerId(autoGeneratedId.incrementAndGet())
                    .resume(career.getResume())
                    .companyName(career.getCompanyName())
                    .careerPosition(career.getCareerPosition())
                    .department(career.getDepartment())
                    .startDate(career.getStartDate())
                    .endDate(career.getEndDate())
                    .build();

            data.add(newCareer);

            return newCareer;
        }

        data.removeIf(item -> Objects.equals(item.getCareerId(), career.getCareerId()));
        data.add(career);
        return career;
    }

    @Override
    public List<Career> update(List<Career> careers) {
        return saveAll(careers);
    }

    private List<Long> getCareerDeleteIds(List<Career> careers, Resume resume) {
        List<Long> careerIds = getCareerIds(resume.getResumeId());
        List<Long> updateIds = getCareerUpdateIds(careers);

        return careerIds.stream().filter(id -> !updateIds.contains(id)).toList();
    }

    @Override
    public List<Career> saveAll(List<Career> careers) {
        return careers.stream().map(this::save).toList();
    }

    @Override
    public void deleteAllById(List<Long> ids) {
        for (Long id : ids) {
            data.removeIf(item -> Objects.equals(item.getCareerId(), id));
        }
    }

    @Override
    public void deleteAllCareers(List<Career> deleteCareers) {
        deleteCareers.stream().map(Career::getCareerId)
                .forEach(id -> data.removeIf(career -> career.getCareerId().equals(id)));
    }


    private List<Long> getCareerUpdateIds(List<Career> careers) {
        return careers.stream().filter(Objects::nonNull).map(Career::getCareerId).toList();
    }

    private List<Long> getCareerIds(Long resumeId) {
        return findAllByResumeId(resumeId).stream().map(Career::getCareerId).toList();
    }


}
